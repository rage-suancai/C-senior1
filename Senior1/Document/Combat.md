实战: 斐波那契数列解法其三

前面我们介绍了函数的递归调用 我们来看一个具体的实例吧 我们还是以解斐波那契数列为例

既然每个数都是前两个数之和 那么我们是否也可以通过递归的形式来不断划分进行计算呢?
我们依然可以借鉴之前动态规划的思想 通过划分子问题 分而治之来完成计算

------------------------------------------------------------------------------------------------------------

实战: 汉诺塔

什么是汉诺塔？

    汉诺塔(Tower of Hanoi) 又称河内塔 是一个源于印度古老传说的益智玩具 大梵天创造世界的时候做了三根金刚石柱子
    在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上
    并且规定 在小圆盘上不能放大圆盘 在三根柱子之间一次只能移动一个圆盘

    https://img-blog.csdnimg.cn/img_convert/7913e4cd66795192278b44fa6fd90403.png

    这三根柱子我们就依次命名为A B C 现在请你设计一个C语言程序 计算N阶(n片圆盘)汉诺塔移动操作的每一步

这个问题看似很难 实际上我们也可以对每一步进行推理:

    当汉诺塔只有1阶的情况下: 直接把A上的圆盘移动到C 搞定

    当汉诺塔只有2阶的情况下 我们的最终目标还是需要将A柱最下面的圆盘丢到C 不过现在多了圆盘 我们得先把这个圆盘给处理了
    所以我们得把这上面的1个圆盘丢到B上去 这样才能把A最下面的圆盘丢给C 然后再把B上面的2个圆盘丢到C上

    当汉诺塔只有3阶的情况下 我们的最终目标还是需要将A柱最下面的圆盘丢到C 不过现在多了圆盘 我们得先把这个圆盘给处理了
    所以我们得把这上面的2个圆盘丢到B上去 这样才能把A最下面的圆盘丢给C 然后再把B上面的1个圆盘丢到C上

实际上我们发现 把A移动到C是一定要进行的 而在进行之前需要先把压在上面的全部的圆盘全部放到B去 而移动之后也要把B上的圆盘全部移动到C上去
所有的情况下最终都会有一个n=1的情况 将A上的最后一个圆盘移动到C 只是多了一个前面的步骤和后面的步骤

不过难点就是 怎么把A上的n-1个圆盘移动到B去呢? 其实这时我们可以依靠C作为中间商 来帮助我们移动(比如n=3 那先把最上面的移动到C
然后把第二大的移动到B 再从C上把最小的移动到B上 这样就借助了C完成了两个圆盘的转移) 而最后又怎么把B上的圆盘全部移到C去呢?
这时可以依靠A作为中间商 方法同理 实际上大问题最后都会变成n=2这样的小问题 只不过是要移动目标不同罢了

只要想通了怎么去借助中间商进行移动 就很好写出程序了

递归函数如下设计:

                    // a存放圆盘的初始柱子 b作为中间柱子存放使用 c作为目标柱子 n表示要从a移动到c的圆盘数
                    void hanoi(char a, char b, char c, int n) {

                    }

现在我们来实现一下吧:

                    void move(char start, char end, int n) { // 用于打印移动操作到控制台 start是起始柱子 end是结束柱子 n是哪一个圆盘
                        printf("第%d个圆盘: %c --> %c\n", n, start, end);
                    }

                    void hanoi(char a, char b, char c, int n) { // 刚进来的时候 B作为中间柱子 C作为目标柱子 要移动A上的n个圆盘到C去
                        if (n == 1) {
                            move(a, c, n); // 无论a, b, C如何变换 通过递归 最后都会变成一个n=1的问题 直接移动就完事了
                        } else {
                            hanoi(a, c, b n-1); // 首要目标是先把上面n-1个圆盘全部放到B去 这里就变换一下 让B作为目标柱子 C作为中间
                            move(a, c, n); // 现在A上只剩下一个最大的圆盘了 接着把A最下方的一个圆盘移到C去
                            hanoi(b, a, c, n-1); // 最后需要把B上的全部搬到C上去 这里就可以以C为目标柱子 A为中间柱子
                        }
                    }

简化一波:

                    void hanoi(char a, char b, int n) {
                        if (n == 0) return;
                        hanoi(a, c, b, n-1);
                        printf("第%d个圆盘: %c --> %c\n", n, a, c);
                        hanoi(b, a, c, n-1);
                    }

看似如此复杂的问题 其实只需要4行就可以解决了

------------------------------------------------------------------------------------------------------------

实战: 快速排序

有一个数组:

                    int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};

现在请你设计一个C语言程序 对数组按照从小到大的顺序进行排序 这里我们使用冒泡排序的进阶版本――快速排序来完成 它的核心思想是分而治之 每一轮排序都会选出一个基准 一轮排序完成后
所以比基准小的数一定在左边 比基准大的数一定在右边 在分别通过同样的方法对左右两边的数组进行排序不断划分 最后完成整个数组的排序 它的效率比冒泡排序的双重for循环有所提升

                    #include <stdio.h>

                    void quickSort(int arr[], int left, int right) { // arr是数组 left是起始下标 right是结束下标

                        // 请实现这部分

                    }

                    int main() {
                        int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
                        quickSort(arr, 0, 9); // 10个数字下标就是0-9
                        for (int i = 0; i < 10; ++i) {
                            printf("%d ", arr[i]);
                        }
                    }


不过虽然这种排序算法很快 但是极端情况下(比如遇到了刚好倒序的数组) 还是会退化成冒泡排序的