函数参数和返回

我们的函数可以接收参数来完成任务 比如我们现在想要实现用一个函数计算两个数的和并输出到控制台

这种情况我们就需要将我们需要进行加法计算的了两个数 告诉函数 这样函数才能对这两个数求和 那么怎么才能告诉函数呢? 我们可以通过设定参数:

                    $include <stdio.h>

                    void test(int, int); // 函数原型中需要写上需要的参数类型 多个参数用逗号隔开 比如这里我们需要的就是两个int类型的参数

                    int main() {

                    }

                    void test(int a, int b) { // 函数具体定义中也要写上 这里的a和b我们称为形式参数(形参) 等价于函数中的局部变量 作用域仅限此函数
                        printf("%d", a + b);
                    }

那么现在定义完成了 该如何使用这个函数呢? 还记得我们怎么使用printf函数的吗? 我们只需要把它所需要的参数填入即可:

                    int main() {
                        test(10, 20); // 这里直接填写一个常量 变量或是运算表达式都是可以的 我们称为实际传入的值为实际参数(实参)
                    }

可以看到 成功计算出结果:

                    30
                    进程已结束,退出代码0

实际上我们传入的实参在进入到函数时 会自动给函数中形参(局部变量)进行赋值 这样我们在函数中就可以得到外部传入的参数值了

                                                                             test(int a) {
                    main() -----调用函数-----> test(10) -----传入实参10----->       // 进入后 此时函数内的局部变量a = 10 
                                                                             }

我们来看看printf函数是怎么写的: 

                    int printf(cosnt char * _restrict, ...) _printflike(1, 2); // 看起来比较高级

这里我们主要关心它的两个参数 一个是char * 由于还没有学习指针 这里就把它当做const char[]就行了 表示一个不可修改的字符串 而第一二个参数我们看到是... 这三个点是个啥?

我们知道 如果我们想要填写具体需要打印的值时 可以一直往后写:

                    printf("%d, %d", 1, 2); // 参数可以一直写

正常情况下我们函数的参数列表都是固定的 怎么才能像这样写很多个呢? 这就要用到可变长参数了 不过可变长参数的使用比较麻烦 这里我们就不做讲解了

这里给大家体验馆问题 如果我们修改形式参数的值 外面的实参会跟着方式修改吗?

                    #include <stdio.h>

                    void swap(int, int);

                    int main() {
                        int a = 10, b = 20;
                        swap(a, b);

                        printf("a = %d, b = %d", a, b); // 最后会得到1什么结果?
                    }

                    void swap(int a, int b) {
                        int tmp = a; // 这里对a和b的值进行交换
                        a = b;
                        b = tmp;
                    }

                    a = 10, b = 20
                    进程已结束,退出代码0

通过结果发现 虽然调用了函数对a和b的值进行交换 但貌似并没有什么卵用 这是为什么呢?

还记得外面前面说的吗 函数的形参实际上就是函数内的局部变量 它的作用域仅仅是这个函数 而外面传入的实参 仅仅只是将值赋给了函数内的形参而已
并且外部的变量跟函数内部的变量作用域都不同 所以半毛钱关心都没有 这里交换的仅仅是函数内部的两个形参变量值 跟外部作实参的变量没有任何关系

那么 怎么样才能实现通过函数交换两个变量的值呢? 这个问题外面会在指针部分进行讨论

不过数组却不受限制 我们在函数中修改数组的值 是直接可以生效的:

                    #include <stdio.h>

                    void test(int arr[]);

                    int main() {
                        int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
                        test(arr);
                        printf("%d", arr[0]); // 打印的是修改后的值了
                    }

                    void test(int arr[]) {
                        arr[0] = 999; // 数组就可以做到这边修改 外面生效
                    }

我们在来看一个例子:

                    #include <stdio.h>

                    void test(int a) {
                        a += 10;
                        printf("%d\n", a);
                    }

                    int main() {
                        int a = 10;
                        test(a);
                        test(a); // 连续两次调用 那么这两次的结果会是什么?
                    }

可以看到结果都是20 (如果猜对了可以直接跳过 如果你猜测的是20和30的话 需要听我解释了)
注意: 每次调用的函数都是单独进行的 并不是复用函数中的形参 不要认为第一次调用函数test就将函数的局部变量变成20了 再次调用就是20+10变成30
实际上这两次调用都是单独进行的 形参a都是在一开始的时候被赋值为实参的值的 这两次调用没有任何关系 并且函数执行完毕后就自动销毁了

那要是我就希望每次调用函数时保留变量的值呢? 我们可以使用静态变量:

                    #include <stdio.h>

                    void test();

                    int main() {
                        test();
                        test();
                    }

                    void test() {
                        static int a = 20; // 静态变量并不会在函数结束时销毁其值 而是保持
                        a += 20;
                        printf("%d", a);
                    }

我们接着来看函数的返回值 并不是所有的函数都是执行完毕就结束了的 可能某些时候我们需要函数告诉我们执行的结果如何
这时我们就需要用到返回值了 比如现在我们希望实现一个函数计算a+b的值:

                    #include <stdio.h>

                    int sum(int, int); // 现在我们要返回a和b的和(那么肯定也是int类型) 所以这里需要将返回值类型修改为int

                    int main() {
                        int a = 10, b = 20; // 计算a和b的和
                        int result = sum(a, b); // 函数执行后 会返回一个int类型的结果 我们可以接收它 也可以像下面一样直接打印 当然也可以参与运算等等
                        printf("a+b=%d", sum(a, b));
                    }

                    int sum(int a, int b) {
                        return a + b; // 通过return关键字来返回计算的结果
                    }

我们接着来看下一个例子 现在我们希望你通过函数找到数组中第一个小于0的数字并将其返回 如果没有找到任何小于0的数 就返回0即可:

                    #include <stdio.h>

                    int findMin(int arr[], int len); // 需要两个参数 一个是数组本身 还有一个是数组的长度

                    int main() {
                        int arr[] = {1, 4, -9, 2, -4, 7};
                        int min = findMid(arr, 6);
                        printf("第一个小于0的数是: %d", min);
                    }

                    int findMin(int arr[], int len) {
                        for (int i = 0; i < len; ++i) {
                            if (arr[i] < 0) return arr[i]; // 当判断找到后 直接return返回即可 这样的话函数会直接返回结果 无论后面还有没有代码没有执行完 整个函数都会直接结束
                        }
                        return 0; // 如果没有找到就返回0
                    }

                    第一个小于0的数是: -9
                    进程已结束,退出代码0

这里我们使用了retur关键字来返回结果 注意当我们的程序走到return时 无论还有什么内容没执行完
整函数都将结束 并返回结果 注意带返回值(非void)的函数中的所有情况都需要有一个对应的返回值:

                    int test(int a) {
                        if (a > 0) {
                            return 10; // 当a大于0时返回语句
                        } else {
                            // 但是当a不大于0时就没有返回值了 这样虽然可以编译通过 但是会有警告(黄标)运行后可能会出现一些无法预知的问题
                        }
                    }

如果是没有返回值的函数 我们也可以调用return来返回 不过默认情况下是可以省略的:

                    void test(int a) {
                        if (a == 10) return; // 因为是void 所以什么都不需要加 直接return
                        printf("%d", a);
                    }